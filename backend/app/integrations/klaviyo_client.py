"""
Klaviyo API Integration Client
"""

import httpx
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta

from app.core.config import settings
from app.core.logging import logger


class KlaviyoClient:
    """
    Client for interacting with Klaviyo API
    """
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://a.klaviyo.com/api"
        self.headers = {
            "Authorization": f"Klaviyo-API-Key {api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json",
            "revision": settings.KLAVIYO_API_VERSION
        }
        
# ... inside KlaviyoClient class ...

    async def create_campaign(
        self,
        campaign_name: str,
        subject_line: str,
        list_id: str,
        html_content: str = "<p>This is a placeholder content generated by Bravola AI.</p>"
    ) -> Dict[str, Any]:
        """
        Create a new Email Campaign in Klaviyo
        """
        url = f"{self.base_url}/campaigns"
        
        # 1. Create the Campaign Wrapper
        payload = {
            "data": {
                "type": "campaign",
                "attributes": {
                    "name": campaign_name,
                    "audiences": {
                        "included": [list_id]
                    },
                    "send_strategy": {
                        "method": "static",
                        "options_static": {
                            "datetime": (datetime.utcnow() + timedelta(days=1)).isoformat()
                        }
                    },
                    "campaign_messages": {
                        "data": [
                            {
                                "type": "campaign-message",
                                "attributes": {
                                    "channel": "email",
                                    "label": campaign_name,
                                    "content": {
                                        "subject": subject_line,
                                        "from_email": "marketing@bravola.com",
                                        "from_label": "Bravola AI",
                                        "reply_to_email": "support@bravola.com",
                                        "html_body": html_content
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    headers=self.headers,
                    json=payload
                )
                response.raise_for_status()
                return response.json().get('data', {})
        except Exception as e:
            logger.error(f"Error creating Klaviyo campaign: {str(e)}")
            raise
    
    async def get_lists(self) -> List[Dict[str, Any]]:
        """Get all lists"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/lists",
                    headers=self.headers
                )
                response.raise_for_status()
                return response.json().get('data', [])
        
        except Exception as e:
            logger.error(f"Error fetching Klaviyo lists: {str(e)}")
            raise
    
    async def get_campaigns(
        self,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """
        Fetch campaigns from Klaviyo
        
        Args:
            limit: Maximum number of campaigns to fetch
        """
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/campaigns",
                    headers=self.headers,
                    params={"page[size]": limit}
                )
                response.raise_for_status()
                return response.json().get('data', [])
        
        except Exception as e:
            logger.error(f"Error fetching campaigns: {str(e)}")
            raise
    
    async def get_campaign_metrics(
        self,
        campaign_id: str
    ) -> Dict[str, Any]:
        """
        Get metrics for a specific campaign
        
        Args:
            campaign_id: Klaviyo campaign ID
        """
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/campaigns/{campaign_id}/relationships/campaign-messages",
                    headers=self.headers
                )
                response.raise_for_status()
                
                messages = response.json().get('data', [])
                
                # Get detailed metrics for the campaign message
                if messages:
                    message_id = messages[0]['id']
                    metrics_response = await client.get(
                        f"{self.base_url}/campaign-messages/{message_id}",
                        headers=self.headers,
                        params={"fields[campaign-message]": "opens,clicks,conversions,revenue"}
                    )
                    metrics_response.raise_for_status()
                    
                    attributes = metrics_response.json().get('data', {}).get('attributes', {})
                    
                    return {
                        'opens': attributes.get('opens', 0),
                        'clicks': attributes.get('clicks', 0),
                        'conversions': attributes.get('conversions', 0),
                        'revenue': attributes.get('revenue', {}).get('amount', 0)
                    }
                
                return {'opens': 0, 'clicks': 0, 'conversions': 0, 'revenue': 0}
        
        except Exception as e:
            logger.error(f"Error fetching campaign metrics: {str(e)}")
            raise
    
    async def get_profiles(
        self,
        list_id: str,
        limit: int = 100
    ) -> List[Dict[str, Any]]:
        """
        Get profiles from a specific list
        
        Args:
            list_id: Klaviyo list ID
            limit: Maximum number of profiles to fetch
        """
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.base_url}/lists/{list_id}/relationships/profiles",
                    headers=self.headers,
                    params={"page[size]": limit}
                )
                response.raise_for_status()
                return response.json().get('data', [])
        
        except Exception as e:
            logger.error(f"Error fetching profiles: {str(e)}")
            raise
    
    async def create_profile(
        self,
        email: str,
        properties: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Create or update a profile
        
        Args:
            email: Profile email address
            properties: Additional profile properties
        """
        try:
            data = {
                "data": {
                    "type": "profile",
                    "attributes": {
                        "email": email,
                        "properties": properties or {}
                    }
                }
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.base_url}/profiles",
                    headers=self.headers,
                    json=data
                )
                response.raise_for_status()
                return response.json().get('data', {})
        
        except Exception as e:
            logger.error(f"Error creating profile: {str(e)}")
            raise
    
    async def get_metrics_summary(
        self,
        days: int = 30
    ) -> Dict[str, Any]:
        """
        Get summary metrics for the specified period
        
        Args:
            days: Number of days to analyze
        """
        try:
            campaigns = await self.get_campaigns(limit=50)
            
            # Filter campaigns from the last N days
            cutoff_date = datetime.utcnow() - timedelta(days=days)
            recent_campaigns = []
            
            for campaign in campaigns:
                send_time = campaign.get('attributes', {}).get('send_time')
                if send_time:
                    campaign_date = datetime.fromisoformat(send_time.replace('Z', '+00:00'))
                    if campaign_date >= cutoff_date:
                        recent_campaigns.append(campaign)
            
            # Aggregate metrics
            total_opens = 0
            total_clicks = 0
            total_conversions = 0
            total_revenue = 0
            
            for campaign in recent_campaigns:
                campaign_id = campaign['id']
                metrics = await self.get_campaign_metrics(campaign_id)
                
                total_opens += metrics.get('opens', 0)
                total_clicks += metrics.get('clicks', 0)
                total_conversions += metrics.get('conversions', 0)
                total_revenue += metrics.get('revenue', 0)
            
            return {
                'total_campaigns': len(recent_campaigns),
                'total_opens': total_opens,
                'total_clicks': total_clicks,
                'total_conversions': total_conversions,
                'total_revenue': round(total_revenue, 2),
                'period_days': days
            }
        
        except Exception as e:
            logger.error(f"Error calculating metrics summary: {str(e)}")
            raise
